# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14zuYk1OYqLX7LEKXUZZIaTV2bLk6O_9e
"""

import numpy as np
import matplotlib.pyplot as plt
import random

def gray2real(indiv,gens):
  j = 0
  g = []
  for i in gens:
    g.append(indiv[j:j+i])
    j += i
  
  bins = []
  for i in g:
    bins.append([i[0]])

  for b,a,k in zip(bins,gens,g):
    for i in range(a-1):
      b.append(int(b[i])^int(k[i+1]))

  R = []
  for b in bins:
    temp = 0
    l = len(b)-1
    for i in range(l+1):
      temp += b[i]*2**(l-i)
    R.append(temp)
  
  R[0] = R[0]+1
  R[1] = R[1]+3
  R[2] = R[2]+2
  R[3] = R[3]+2

  return R

def voltajes(R):
  #R =  [m,n,w,l]
  c = 5.90625*(10**(-5))
  gam = R[1]*(R[0]+1)*R[2]/R[3]
  V = [1.001*(10**(-7)),2.5*(10**(-2)),0.1,0.225,0.4,0.625,0.9,1.225,1.567761,1.844197,2.070994]
  Vr = []
  Vg = []
  for i in range(11):
    Vr.append(((0.5*i-0.69)**(2))*c*gam)
    Vg.append(0.5*i)
    
  font2 = {'family':'serif','color':'black','size':15}

  plt.plot(Vg,Vr)
  plt.plot(Vg,V,marker = 'o')
  plt.xlabel("Vgs", fontdict = font2)
  plt.ylabel("VR", fontdict = font2)
  plt.show()

  return 1

def fitness(R):
  #R =  [m,n,w,l]
  c = 5.90625*(10**(-5))
  gam = R[1]*(R[0]+2/3)*R[2]/R[3]
  V = [1.001*(10**(-7)),2.5*(10**(-2)),0.1,0.225,0.4,0.625,0.9,1.225,1.567761,1.844197,2.070994]
  E = 0
  for i in range(11):
    E += ((0.5*i-0.69)**2*c*gam-V[i])**2
  E = -E/11
  return E

def mutation(indiv):
    if random.random()<0.05:
        index = random.randint(0,len(indiv)-1)
        if indiv[index] == 1:
            indiv[index] = 0
        else:
            indiv[index] = 1

    return indiv

def crossover(parent0, parent1):
    offspring0 = []
    offspring1 = []
    if random.random()<0.70:
        cut = random.randint(0,len(parent0)-1)
        for i in range(len(parent0)):
            if i <= cut:
                offspring0.append(parent0[i])
                offspring1.append(parent1[i])
            else:
                offspring0.append(parent1[i])
                offspring1.append(parent0[i])
    else:
        offspring0 = parent0
        offspring1 = parent1

    return offspring0, offspring1

def selection(fit):
    totalfit = sum(fit)
    pick = random.random()

    fit_p = []
    for i in range(len(fit)):
        fit_p.append(fit[i]/totalfit)

    fit_acc = 0
    for i in range(len(fit)):
        fit_acc += fit_p[i]
        if fit_acc >= pick:
            fit_index = i
            break

    return fit_index

def population(n,c_len):
    pop = []
    for i in range(n):
        pop.append(newindiv(c_len))
    return pop

def newindiv(c_len):
  indv = []
  for i in range(c_len):
      if random.random()>0.5:
          indv.append(1)
      else:
          indv.append(0)
  return indv

def main():
    #create initial population
    #num. of individuals
    n = random.randint(32,64)
    #length of chromosome
    gens = []  #length of genes
    # chromosome = [m,n,w,l]
    gens.append(random.randint(5,7)) # m
    gens.append(random.randint(4,6)) # n
    gens.append(random.randint(4,6)) # w
    gens.append(random.randint(4,6)) # l
    c_len = sum(gens)
    tg = 1000  # max generations
    pop = population(n,c_len)
    #######################################
    print("*** Genetic Algorithm ***")
    print("Population size:\t",n)
    print("Chromosome length:\t",c_len)
    print("Chromosome config:\t",gens)

    bestfits_g = []
    #tg = 1000 #max generations
    for i in range(tg):
      fit = []
      for indiv in pop:
          fit.append(fitness(gray2real(indiv,gens)))

      fit_index = selection(fit)
      parent0 = pop[fit_index]

      fit_index = selection(fit)
      parent1 = pop[fit_index]
      while parent0==parent1:
          fit_index = selection(fit)
          parent1 = pop[fit_index]

      offspring0, offspring1 = crossover(parent0,parent1)

      offspring0 = mutation(offspring0)
      offspring1 = mutation(offspring1)

      fitp0 = fitness(gray2real(parent0,gens))
      fitp1 = fitness(gray2real(parent1,gens))
      fito0 = fitness(gray2real(offspring0,gens))
      fito1 = fitness(gray2real(offspring1,gens))

      newpop = []
      # Selection of individuals
      if fito0>=fitp0 or fito0>=fitp1:
          newpop.append(offspring0)
      if fito1>=fitp0 or fito1>=fitp1:
          newpop.append(offspring1)
      if fitp0>fito0 and fitp0>fito1:
          newpop.append(parent0)
      if fitp1>fito0 and fitp1>fito1:
          newpop.append(parent1)

      bestfit = max(fit)
      bestindex = fit.index(bestfit)
      newpop.append(pop[bestindex])

      # Extender Elitismo
      meanfit = np.mean(fit)
      stddevfit = np.std(fit)

      for i in range(len(fit)):
          if fit[i]>(meanfit+stddevfit):
              newpop.append(pop[i])

      # Fillers
      while(len(newpop)<n):
          newpop.append(newindiv(c_len))

      fit = []
      for indiv in newpop:
          fit.append(fitness(gray2real(indiv,gens)))
      
      bestfit = max(fit)
      bestfits_g.append(bestfit)
      pop = newpop

    bestindex = fit.index(bestfits_g[-1])
    bestIndiv = gray2real(pop[bestindex], gens)
    print("Best Error:", bestfits_g[-1])
    print("Individual [m,n,w,l] =", gray2real(pop[bestindex], gens))
    print("R =", (bestIndiv[1] * (bestIndiv[0] + 1 / 3) + 1 / 3) * 25, "ohms")
    print("W =", bestIndiv[2] * 0.3, "um")
    print("L =", bestIndiv[3] * 0.3, "um")
    print("W/L =", bestIndiv[2] / bestIndiv[3])
    print("RW/L =", (bestIndiv[1] * (bestIndiv[0] + 1 / 3) + 1 / 3) * 25 * bestIndiv[2] / bestIndiv[3])
    plt.figure(1)
    plt.plot(bestfits_g)
    plt.show()
    voltajes(gray2real(pop[bestindex], gens))

main()